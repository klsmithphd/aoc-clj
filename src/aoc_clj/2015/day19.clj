(ns aoc-clj.2015.day19
  "Solution to https://adventofcode.com/2015/day/19"
  (:require [clojure.string :as str]
            [aoc-clj.utils.core :as u]))

;; Input parsing
(defn parse-replacement
  [line]
  (str/split line #" => "))

(defn parse
  [input]
  (let [[replacements molecule] (u/split-at-blankline input)]
    {:replacements (mapv parse-replacement replacements)
     :molecule (first molecule)}))

;; Puzzle logic
(defn match-ranges
  "Find all the (potentially overlapping )index ranges of any sub-string
   matches of pattern"
  [s pattern]
  (let [len     (count pattern)
        indices (->> (map-indexed vector (partition len 1 s))
                     (filter #(= pattern (apply str (second %))))
                     (map first))]
    (map #(vector % (+ % len)) indices)))

(defn replacement
  "Return a new string based off of `s`, where the characters in the
   range [`start`, `end`) are replaced by `new`"
  [s new [start end]]
  (str (subs s 0 start) new (subs s end)))

(defn single-replacements
  "Returns all possible new strings with the replacement mapping old->new"
  [s [old new]]
  (map #(replacement s new %) (match-ranges s old)))

(defn distinct-molecules
  "All the distinct variants of `molecule` that can be generated from the `replacements`"
  [{:keys [replacements molecule]}]
  (distinct (mapcat #(single-replacements molecule %) replacements)))

(defn ordered-replacements
  "Modifies the input to sort the replacement rules in descending order by size
   of the replacement (new) component, and reversing the order so that the
   replacements are structured new -> old. This allows us to work backward
   from the target molecule"
  [{:keys [replacements] :as input}]
  (assoc input :replacements (map reverse (sort-by (comp count second) > replacements))))

(defn de-fabricate
  "Take the first replacement that successfully changes the given molecule
   into a smaller (earlier) version, unless we reach `e`"
  [{:keys [replacements molecule] :as input}]
  (assoc input :molecule
         (if (= "e" molecule)
           "e"
           (first (mapcat #(single-replacements molecule %) replacements)))))

(defn fabrication-steps
  "Determine the sequence of successive molecule changes to get to the
   target molecule starting at `e`. (Sequence returns in the reverse order)"
  [input]
  (->> (ordered-replacements input)
       (iterate de-fabricate)
       (take-while #(not= "e" (:molecule %)))
       (map :molecule)))

;; Puzzle solutions
(defn part1
  "The number of distinct molecules that can be generated by the replacements"
  [input]
  (count (distinct-molecules input)))

(defn part2
  "The smallest number of replacement steps it takes to go from `e` to the 
   target molecule"
  [input]
  (count (fabrication-steps input)))