(ns aoc-clj.2017.day15
  "Solution to https://adventofcode.com/2017/day/15"
  (:require [aoc-clj.utils.math :as math]))

;; Constants
(def lower-sixteen 65535)
(def a-mul 16807)
(def b-mul 48271)
(def modulus 2147483647)
(def part1-limit 40000000)
(def part2-limit  5000000)

;; Input parsing
(defn parse
  [input]
  (->> (map #(re-find #"\d+" %) input)
       (map read-string)))

;; Puzzle logic
(defn gen-a
  "Generates next value for Generator A"
  [num]
  (math/mod-mul modulus a-mul num))

(defn gen-b
  "Generates next value for Generator B"
  [num]
  (math/mod-mul modulus b-mul num))

(defn lower-bits-match?
  "Do the two numbers match in their lower sixteen bits?"
  [[a b]]
  (= (bit-and a lower-sixteen) (bit-and b lower-sixteen)))

(defn part1-pairs
  "A sequence, up to limit, of pairs of values generated by A & B"
  [limit [start-a start-b]]
  (->> (map vector
            (drop 1 (iterate gen-a start-a))
            (drop 1 (iterate gen-b start-b)))
       (take limit)))

(defn mod-4?
  "Is the number a multiple of 4?"
  [num]
  ;; Uses the trick that a number is a multiple of 4 if it ANDs to zero
  ;; with 4-1 = 3, i.e., 011
  (zero? (bit-and num 3)))

(defn mod-8?
  "Is the number a multiple of 8?"
  [num]
  ;; ANDs to zero with 8-1 = 7 = 0111
  (zero? (bit-and num 7)))

(defn part2-pairs
  "A sequence, up to limit, of pairs of values generated by A & B
   using the modified logic in Part 2"
  [limit [start-a start-b]]
  (->> (map vector
            (filter mod-4? (drop 1 (iterate gen-a start-a)))
            (filter mod-8? (drop 1 (iterate gen-b start-b))))
       (take limit)))

(defn judge-count
  [pair-seq limit init-vals]
  (->> (pair-seq limit init-vals)
       (filter lower-bits-match?)
       (count)))

;; Puzzle solutions
(defn part1
  "After 40 million pairs, what is the judge's final count?"
  [input]
  (judge-count part1-pairs part1-limit input))

(defn part2
  "After 5 million pairs, using the new logic, what is the judge's final count?"
  [input]
  (judge-count part2-pairs part2-limit input))